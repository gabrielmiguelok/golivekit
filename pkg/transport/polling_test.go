package transport

import (
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

func TestLongPolling_RequiresAuth(t *testing.T) {
	config := DefaultTransportConfig()
	lpConfig := &LongPollingConfig{
		RequireAuth: true,
		TokenValidator: func(token string) (bool, error) {
			return token == "valid-token", nil
		},
		HMACSecret:     []byte("test-secret"),
		ClientIDExpiry: time.Hour,
	}

	handler := NewLongPollingHandlerWithConfig(config, lpConfig, nil)

	tests := []struct {
		name       string
		token      string
		expectCode int
	}{
		{
			name:       "no token rejected",
			token:      "",
			expectCode: http.StatusUnauthorized,
		},
		{
			name:       "invalid token rejected",
			token:      "invalid-token",
			expectCode: http.StatusUnauthorized,
		},
		{
			name:       "valid token accepted",
			token:      "valid-token",
			expectCode: http.StatusOK,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			req := httptest.NewRequest("POST", "/connect", nil)
			if tt.token != "" {
				req.Header.Set("X-Auth-Token", tt.token)
			}

			w := httptest.NewRecorder()
			handler.Connect(w, req)

			if w.Code != tt.expectCode {
				t.Errorf("Expected status %d, got %d", tt.expectCode, w.Code)
			}
		})
	}
}

func TestLongPolling_ClientIDSigned(t *testing.T) {
	config := DefaultTransportConfig()
	lpConfig := &LongPollingConfig{
		RequireAuth:    false,
		HMACSecret:     []byte("test-secret-key-32-bytes-long!!"),
		ClientIDExpiry: time.Hour,
	}

	transport := NewLongPollingTransportWithConfig(config, lpConfig)

	// Generate a signed client ID
	clientID, err := transport.generateSignedClientID()
	if err != nil {
		t.Fatalf("Failed to generate client ID: %v", err)
	}

	// Verify the signature is valid
	if !transport.verifyClientIDSignature(clientID) {
		t.Error("Generated client ID should have valid signature")
	}

	// Verify tampering is detected
	if transport.verifyClientIDSignature(clientID + "x") {
		t.Error("Tampered client ID should be rejected")
	}

	if transport.verifyClientIDSignature("completely-fake-id") {
		t.Error("Fake client ID should be rejected")
	}
}

func TestLongPolling_InvalidSignatureRejected(t *testing.T) {
	config := DefaultTransportConfig()
	lpConfig := &LongPollingConfig{
		RequireAuth:    false,
		HMACSecret:     []byte("test-secret"),
		ClientIDExpiry: time.Hour,
	}

	handler := NewLongPollingHandlerWithConfig(config, lpConfig, nil)

	// First connect to create a transport
	connectReq := httptest.NewRequest("POST", "/connect", nil)
	connectW := httptest.NewRecorder()
	handler.Connect(connectW, connectReq)

	if connectW.Code != http.StatusOK {
		t.Fatalf("Connect failed: %d", connectW.Code)
	}

	// Try to poll with a fake client ID
	pollReq := httptest.NewRequest("GET", "/poll?client_id=fake-unsigned-id", nil)
	pollW := httptest.NewRecorder()
	handler.Poll(pollW, pollReq)

	// Should be rejected (not found because transport doesn't exist)
	if pollW.Code != http.StatusNotFound {
		t.Errorf("Expected 404 for non-existent fake ID, got %d", pollW.Code)
	}
}

func TestLongPolling_ExpiredClientIDRejected(t *testing.T) {
	config := DefaultTransportConfig()
	lpConfig := &LongPollingConfig{
		RequireAuth:    false,
		HMACSecret:     []byte("test-secret"),
		ClientIDExpiry: 1 * time.Nanosecond, // Expire immediately
	}

	transport := NewLongPollingTransportWithConfig(config, lpConfig)

	// Generate a client ID
	clientID, err := transport.generateSignedClientID()
	if err != nil {
		t.Fatalf("Failed to generate client ID: %v", err)
	}

	// Wait for expiry
	time.Sleep(10 * time.Millisecond)

	// Should be rejected due to expiry
	if transport.verifyClientIDSignature(clientID) {
		t.Error("Expired client ID should be rejected")
	}
}

func TestDefaultLongPollingConfig(t *testing.T) {
	config := DefaultLongPollingConfig()

	if config.RequireAuth {
		t.Error("RequireAuth should be false by default")
	}

	if len(config.HMACSecret) == 0 {
		t.Error("HMACSecret should be generated by default")
	}

	if config.ClientIDExpiry != 24*time.Hour {
		t.Error("ClientIDExpiry should be 24h by default")
	}
}
